#!/usr/bin/env python3.4
#
# This file is part of dashboard.
#
# dashboard is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# dashboard is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with environmentd.  If not, see <http://www.gnu.org/licenses/>.

# pylint: disable=broad-except
# pylint: disable=invalid-name

"""Run from a systemd timer to generate status json that is served by the web dashboard"""

import datetime
import json
from warwick.observatory.common import daemons, log

# This directory must be shared with the TCS via NFS
BASE_OUTPUT_DIR = '/srv/dashboard/generated'
STATUS_FILE = BASE_OUTPUT_DIR + '/update-dashboard-data.json'

try:
    with open(STATUS_FILE, 'r') as infile:
        status = json.load(infile)
except Exception:
    status = {}

def generate_json(output_path, data, force_key=False):
    """Queries a set of daemons and stores the save a json file to the specified path"""
    output = {'date': datetime.datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%f')}
    for daemon, key, query in data:
        try:
            with daemon.connect() as d:
                response = query(d)

            # Some daemons will return None on error
            if response is None:
                if not key in status or status[key]:
                    print('recieved empty response from ' + key + '')
                    log.error('dashboardd', 'Lost contact with ' + key + ' (empty response)')
                status[key] = False
            else:
                if len(data) == 1 and not force_key:
                    output = response
                else:
                    output[key] = response
                if key in status and not status[key]:
                    log.info('dashboardd', 'Restored contact with ' + key)
                status[key] = True
        except Exception as e:
            print('failed to query ' + key + ' with error: ' + str(e))
            if not key in status or status[key]:
                log.error('dashboardd', 'Lost contact with ' + key + ' (' + str(e) + ')')
            status[key] = False
    try:
        with open(output_path, 'w') as output_file:
            json.dump(output or {}, output_file)

        with open(STATUS_FILE, 'w') as output_file:
            json.dump(status, output_file)
    except Exception as e:
        print('failed to write json with error: ' + str(e))
        log.error('dashboardd', 'Failed to write json (' + str(e) + ')')

# One metre dashboard pages
generate_json(BASE_OUTPUT_DIR + '/onemetre-public.json', [
    (daemons.onemetre_environment, 'environment', lambda d: d.status()),
    (daemons.onemetre_operations, 'ops', lambda d: d.status()),
    (daemons.onemetre_power, 'power', lambda d: d.last_measurement()),
])

generate_json(BASE_OUTPUT_DIR + '/onemetre-private.json', [
    (daemons.onemetre_pipeline, 'pipeline', lambda d: d.report_status()),
    (daemons.onemetre_telescope, 'telescope', lambda d: d.report_status()),
    (daemons.onemetre_blue_camera, 'blue', lambda d: d.report_status()),
    (daemons.onemetre_red_camera, 'red', lambda d: d.report_status())
])

# RASA dashboard pages
generate_json(BASE_OUTPUT_DIR + '/rasa-public.json', [
    (daemons.rasa_environment, 'environment', lambda d: d.status()),
    (daemons.rasa_power, 'power', lambda d: d.last_measurement()),
])

generate_json(BASE_OUTPUT_DIR + '/rasa-private.json', [
    (daemons.rasa_operations, 'ops', lambda d: d.status()),
    (daemons.rasa_telescope, 'telescope', lambda d: d.report_status()),
    (daemons.rasa_dome, 'dome', lambda d: d.status()),
    (daemons.rasa_camera, 'cam', lambda d: d.report_status()),
    (daemons.rasa_focus, 'focus', lambda d: d.report_status()),
    (daemons.rasa_pipeline, 'pipeline', lambda d: d.report_status()),
])

# GOTO dashboard pages
generate_json(BASE_OUTPUT_DIR + '/goto-public.json', [
    (daemons.goto_gtecs_conditions, 'conditions', lambda d: d.get_info(force_update=False)),
], force_key=True)

generate_json(BASE_OUTPUT_DIR + '/goto-private.json', [
    (daemons.goto_gtecs_power, 'power', lambda d: d.get_info(force_update=False)),
    (daemons.goto_gtecs_mnt, 'mnt', lambda d: d.get_info(force_update=False)),
    (daemons.goto_gtecs_dome, 'dome', lambda d: d.get_info(force_update=False)),
    (daemons.goto_gtecs_filt, 'filt', lambda d: d.get_info(force_update=False)),
    (daemons.goto_gtecs_foc, 'foc', lambda d: d.get_info(force_update=False)),
    (daemons.goto_gtecs_cam, 'cam', lambda d: d.get_info(force_update=False)),
    (daemons.goto_gtecs_exq, 'exq', lambda d: d.get_info(force_update=False)),
])

# Raw data for GOTO operations
generate_json(BASE_OUTPUT_DIR + '/onemetre-vaisala.json', [
    (daemons.onemetre_vaisala, 'vaisala', lambda d: d.last_measurement())
])

generate_json(BASE_OUTPUT_DIR + '/goto-vaisala.json', [
    (daemons.goto_vaisala, 'goto-vaisala', lambda d: d.last_measurement())
])

generate_json(BASE_OUTPUT_DIR + '/superwasp-log.json', [
    (daemons.superwasp_log, 'superwasp', lambda d: d.last_measurement())
])

generate_json(BASE_OUTPUT_DIR + '/netping.json', [
    (daemons.observatory_network_ping, 'netping', lambda d: d.last_measurement())
])
